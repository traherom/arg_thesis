\chapter{Implementation}
\label{chp:implementation}

\par The research this thesis presents relies on a custom-developed \ac{IP} address hopping solution. This chapter covers many of the details of this system, from high-level architecture to the network protocol. Section \ref{sec:arg_requirements} covers the requirements this system strives to meet. Section \ref{sec:arg_impl_overview} gives an architecture overview, while Section \ref{sec:arg_components} covers the details of each component in the system. Section \ref{sec:arg_protocol} details the network protocol used by the system to coordinate gateways.

\section{Requirements}
\label{sec:arg_requirements}
\par \ac{ARG} focuses on the needs of military networks. These are essentially the needs of any geographically-diverse organization: locations throughout the world, high availablity and reliability requirements, and security over any network through which its data travels. 

\par ARG worries primarily about protecting communication outside of military-controlled networks and preventing external entities from probing internally. This means that the implementation described is intended to be employed for all traffic traveling between bases, but is unconcerned with internal base traffic. Internal network defense remains the purview of traditional defenses. Base networks, in this case, include both those on permanent installations and those in deployed, forward locations. 

\par ARG must operate over the commercial Internet. As mentioned in Section \ref{sec:related_research} \tbd{contra isn't actually covered}, some proposals for network address space randomization require changes to the Internet's existing routing infrastructure, protocol-wise \cite{CONTRA}. Deploying such a solution may be possible and beneficial in the long run, but a solution that could be deployed today without participation from outside entities is more feasible. This is especially true for forward locations, where traffic is more likely to utilize infrastructure outside the military's control.

\par Base networks can generate huge volumes of traffic, so ARG must scale well. Due to the importance of networks to command and control, ARG's implementation must not introduce significant latency under any foreseeable load. Likewise, there can never be a brief period where all connections drop. At a minimum, given the number of nodes inside the network, dropped connections would result in a massive amount of wasted bandwidth as they were reestablished and the data retransmitted.

\par Military networks contain a wide range of hardware and software. Much of this software cannot be altered to accommodate \ac{ARG}, so it must function transparently. Host-level implementations might be feasible for generic workstation images---i.e., an alteration to the operating system's network stack---, but the ability to function in another way must exist to allow legacy equipment to continue operating.

%\par Finally, resource constraints---monetary and manpower---preclude some options. ARG is intended to be easily configurable and usable with reasonable hardware investments. ARG requires only a single gateway system for each network it is intended to protect, rather than hardware and/or software for every client inside those networks.

\section{Architecture Overview}
\label{sec:arg_impl_overview}
%\par Based on these requirements and the previously cited literature, this paper proposes the Address Routing Gateway. While actual testing of this setup is beyond the scope of this paper, we will attempt to analyze the advantages it would provide, based on previous experimentation.

\par As illustrated in Figure \ref{fig:argnetwork}, \ac{ARG} functions entirely around standard networks with hopping gateways. This matches the ``gateway hopping'' scheme discussed in Section \ref{sec:gateway_hopping}. As with \cite{TAO}, these gateways are standalone systems, not intended for use with other tasks. Individual hosts inside these networks have no knowledge of the traffic transformations the gateways perform, whether their connections are routing to a host inside the local network, to a host inside another associated hopping network (hereafter referred to as an ``ARG network''), or to an external network. The implementation of ARG allows the deployment of standard passive defense technologies like firewalls inside the network without reconfiguration. Each gateway maintains a \ac{NAT}-like table to ensure that existing connections are maintained across hops (essentially temporarily leaving the old IP active for just those connections using it already).

% TBD remove the top system on diagram and make the WAN the Internet
\begin{figure}
	\centering
	\includegraphics[width=0.75\textwidth]{arg_concept_network}
	\caption{ARG network layout overview}
	\label{fig:argnetwork}
\end{figure}

\par Each gateway is pre-configured with knowledge of at least one other gateway. The configured information consists of the subnet the other gateway is handling and a public key to use for authentication with it. Additionally, the gateway must be given what subnet it is permitted to hop within, its own private key, and how frequently it should change IPs (frequently referred to here as a ``hop'').

\par At startup, each gateway generates a random symmetric encryption key and a ``hop key.'' They then attempt to connect to all other gateways for which they have configuration files through a series of data and time synchronization packets. Once two gateways fully connect, they exchange data about all other gateways they have configured, allowing ARG nodes to connect to gateways they do not have physical configuration files for. Periodically gateways re-send time synchronization information, ensuring that changing network conditions do not kill communication. Section \ref{sec:arg_protocol} covers this process in more detail.

\par Once connected, packets between ARG networks are encapsulated, encrypted, and authenticated by the originating network's gateway, with the each packet given the destination network's current IP. On receipt, a gateway checks that the IPs match what they expect (both its own IP and the source's IP), then validates the signature/\ac{HMAC} before dropping the original packet into their network. \acp{IP} may match either the current \ac{IP} or the previous one, allowing packets sent just before an \ac{IP} change to still be accepted. Packets to external hosts flow through the \ac{NAT}-style system covered in Section \ref{sec:arg_nat}. %These two processes are distinct in their operation and are covered separately in Section \ref{sec:modules}.

%\par Multi-homed networks are not taken into account in this proposal. Further research is needed to see what changes would need to be made to support this setup. If an ARG gateway were placed at each of the connections to the outside network, it is likely that some communication between the two is required to keep them working together \cite{SandiaDynat}, but the exact form this would take needs consideration. \tbd{move to limitations?}

\section{Components}
\label{sec:arg_components}
The handling of packets within ARG is distinctly different if they are to an external (non-ARG network) host or to an ARG network. These processes are handled by two separate components, the hopper and the NAT. A high-level director decides which of these two receives incoming packets. Because it is in charge of overall system operation, this thesis begins by discussing the director.

\subsection{Director}
\label{sec:arg_director}
\par The director is in charge of receiving packets on the internal and external interfaces of the gateway. Upon receipt of a packet, the director parses the packet and decides how to handle it. The decision tree it follows is illustrated in Figure \ref{fig:arg_director_flow}.

\begin{figure}
\caption{\ac{ARG} Director Flow}
\label{fig:arg_director_flow}
\centering
\includegraphics[width=1.0\textwidth,clip=true,trim=0 0 0 0]{flow_director}
\end{figure}

\par In the case of \ac{ARP} requests on either interface, the director replies with the gateway's \ac{MAC} address. This feature of \ac{ARG} allows its use without any changes to the network it is placed in, as hosts continue to send to the ``same'' gateway IP as before and \ac{ARG} pretends to fullfill that role. 

\par For outgoing packets---packets that are sent by the protected network that are intended to leave the network---, the director checks the destination \ac{IP} of the packet. If the IP is unknown, it is passed to the \ac{NAT} module. If the IP is within another \ac{ARG} network the director knows of, the packet is handed off to the hopper module to be wrapped and transmitted.

\par For incoming packets---packets hitting the external interface---, the director first checks if the source IP is another ARG network. If it is \textit{not}, the director quickly hands the packet off to the NAT inbound handler.

\par If the packet \textit{is} from another ARG network, the director checks if the packet type indicates it is an administrative packet and hands it off to the hopper's administrative processor. If it is not an administrative packet, then the director ensures that the gateway the packet is from is actually connected and that the source and destination IPs are correct, based on the data the hopper has on the other gateway. Assuming all those checks pass, the packet is handed off to the hopper to be unwrapped and dropped into the network.

\subsection{Hopper}
\label{sec:arg_hopper}
\par The hopping module is the heart of ARG. It handles maintaining the state of the gateways it knows about---keys, hop rates, times---and using that state to transfer packets to and from the network it is protecting. The other two components (director and \ac{NAT}) talk to the hopper to obtain current IP information and if a given gateway is connected or not. 

\par When the hopper first starts, it initializes a list of gateways with data from configuration files. The information maintained in this structure is shown in Table \ref{tab:gatestate}. 

\begin{table}
\caption{Information hopper maintains on other ARG gateways}
\label{tab:gatestate}
\centering
\begin{tabular}{l|l}
	Data & Notes \\
	\hline
	IP Range (IP and mask) & Configuration file \\
	\ac{RSA} Public Key & Configuration file \\
	Hop Interval & Transferred \\
	Symmentric Key & Transferred \\
	Hop Key & Transferred \\
	Time Base & Calculated \\
\end{tabular}
\end{table}

\par An administrative thread is started at the same time. This thread attempts to connect to each gateway in its list periodically and, if it does not hear from a given gateway for several minutes, marks gateways as disconnected. In addition, it fairly frequently sends time synchronization requests to connected gateways, especially if it sees a large percentage of packets being rejected by \ac{IP} address. 

\par Beyond the administative thread, actions occur in the hopper only when the director passes off packets to it. Outgoing packets are always wrapped, encrypted, and signed, as covered under the ``route packet'' process in Section \ref{sec:arg_protocol_route}. Incoming packets go through the validation process shown in Figure \ref{fig:arg_hopper_in_validation} before being handled. Note that \ac{IP} checking is done in the Director before control reaches the Hopper. After validation exact handling depends on the packet type, but is generally covered in Section \ref{sec:arg_protocol} as part of the protocol discussion.

\begin{figure}
\caption{\ac{ARG} Incoming Packet Validation}
\label{fig:arg_hopper_in_validation}
\centering
\includegraphics[width=1.0\textwidth,clip=true,trim=0 0 1in 3in]{flow_packet_validation}
\end{figure}

\subsection{\ac{ARG} \ac{NAT}}
\label{sec:arg_nat}
\par The \ac{NAT} component of \ac{ARG} maintains a list of on-going connections to external hosts. For instance, if a client inside a protected network connects to 54.24.234.63, the \ac{NAT} creates an entry in an internal table and allows packets from the external host back in to the network and to the client. This is almost identical to the operation of the basic \ac{NAT} discussed in Section \ref{sec:nat}.

\par The only difference from a normal \ac{NAT} system is the addition of an extra field for the current \ac{IP} in the \ac{NAT} table. The new version of the table with example data is shown in Table \ref{tab:arg_nat_example} with the new column in bold.

\begin{table}
\caption{NAT Table Example}
\label{tab:arg_nat_example}
\centering
\begin{tabular}{r|cccccc}
  & Int IP & Int Port & Remote IP & Remote Port & \textbf{Ext IP} & Ext Port\\
\hline
1 & \texttt{192.168.0.103} & 3547 & \texttt{74.125.225.69} & 443 & \textbf{\texttt{172.1.123.35}} & 50003\\
2 & \texttt{192.168.0.103} & 8751 & \texttt{207.109.73.34} & 80 & \textbf{\texttt{172.1.73.1}} & 42630\\
3 & \texttt{192.168.0.112} & 30452 & \texttt{4.27.2.253} & 80 & \textbf{\texttt{172.1.86.173}} & 53920
\end{tabular}
\end{table}

\par The traditional \ac{NAT} processing and logic is supplemented with this additional information. When a packet goes out, the table is checked and the packet has its source IP and port changed to the external values. If this is the first packet in a connection, the external IP is filled from the current IP of the gateway. When an incoming packet is encountered, the exteral IP and port are both checked to determine the correct internal host. The additon of the external IP to the table allows connections to survive across hops; many connections last longer than \ac{ARG}'s intended hop rate and severing connections frequently is unacceptable. 

\section{Protocol}
\label{sec:arg_protocol}
\par The \ac{ARG} protocol is designed to be fairly stateless, simplifying the implementation and lowering the likelihood of an exploit by placing the gateway into an unexpected state. Packets are sent at the transport layer because port numbers are not needed, but the protocol could be adapted easily to work as a \ac{UDP} payload. \ac{ARG} packets are identified by \ac{IP} protocol 253, a protocol reserved for experimentation \cite{IANAPorts}. The header structure of an \ac{ARG} packet is shown in Table \ref{tab:arg_packet_structure}.

\begin{table}
\caption{ARG Packet Structure, four bytes wide}
\label{tab:arg_packet_structure}
\centering
\begin{tabular}{*{4}{|p{2cm}}|}
	\hline
	1 & 2 & 3 & 4\\
	\hline
	\hline
	version & type & \multicolumn{2}{c|}{length}\\
	\hline
	\multicolumn{4}{|c|}{sequence number}\\
	\hline
	\multicolumn{4}{|c|}{128 bytes - signature}\\
	\hline
	\multicolumn{4}{|c|}{\textit{...additional data...}}\\
	\hline
\end{tabular}
\end{table}

\par For this research, the protocol version field is set to 1 at all times. The type field tells the receiving gateway how to process the data contained in the message. Possible values are shown in Table \ref{tbl:arg_protocol_types}. \tbd{More details on the format of each message/type is given below. Too much?} Length is the network-order size in bytes of the data from the version to the end of the data; given the size of the message header, the minimum for this is 136. The sequence number is a monotonically increasing unsigned integer value used to prevent replay attacks.

\begin{table}
\caption{\ac{ARG} Message Types}
\label{tbl:arg_protocol_types}
\begin{tabular}{l|c|l}
Mnemonic & Value & Description\\
\hline
\texttt{WRAPPED} & 1 & Encapsulated packet from protected client to protected client\\
\texttt{PING} & 2 & Time synchronization message\\
\texttt{CONN\_RESP} & 3 & Connection data response message\\
\texttt{CONN\_REQ} & 4 & Connection data and request for other gateway's data\\ 
\texttt{TRUST\_DATA} & 5 & Config information 
\end{tabular}
\end{table}

\par The signature field may actually contain two possible values: a true \ac{RSA} digital signature of the packet or an \ac{HMAC} of the packet, depending on the message type. Packets of type \texttt{PING} or either \texttt{CONN\_DATA} are signed with the private key of the sender and encrypted with the public key of the receiver. All other packets---types \texttt{WRAPPED} and \texttt{TRUST\_DATA}---include an \ac{HMAC} using with the symmetric key of the sender and encrypted with the symmetric key of the receiver. The encryption and signing combinations used for each message type as well as whether or not the source and destination \ac{IP}s are strictly checked are summarized in Table \ref{tbl:arg_protocol_security}.

\begin{table}
\caption{\ac{ARG} Message Security}
\label{tbl:arg_protocol_security}
\centering
\begin{tabular}{l|l|l|l}
Type & Encryption & Signing & \ac{IP}s checked?\\
\hline
\texttt{WRAPPED} & AES, remote key & HMAC, local key & Yes\\
\texttt{PING} & RSA, remote public key & Signature, local private key & No\\
\texttt{CONN\_RESP} & RSA, remote public key & Signature, local private key & No\\
\texttt{CONN\_REQ} & RSA, remote public key & Signature, local private key & No\\
\texttt{TRUST\_DATA} & AES, remote key & HMAC, local key & No\\
\end{tabular}
\end{table}

\par There are four basic exchanges that happen between \ac{ARG} gateways: connect, time sync, trust data exchange, and packet transfer. In order for gateways to begin exchanging packets between the networks they are protecting (via the ``route packet'' process), they must first fully connect by completing the connect and time sync processes. The trust data exchange step is optional, although it allows gateways to connect to others without configuration files. The steps for each are given in the sections below. In the following descriptions, local is the current gateway and remote is another gateway with which it is communicating. The steps assume that local is the initiator of a given exchange.

\subsection{Connect process}
\begin{enumerate}
	\item Local sends \texttt{CONN\_REQ} containing its hop key, hop interval, and symmetric key. 
	\item After validating the packet, remote saves the connection data.
	\item Remote sends \texttt{CONN\_RESP} acknowledgement back, containing its own hop key, hop interval, and symmetric key. 
	\item Local receives data and saves it.
	\item Local marks the remote gateway as having connection data and, if time sync data is available, remote is marked as connected. 
\end{enumerate}

\subsection{Time sync}
\begin{enumerate}
	\item Local sends \texttt{PING} containing random 4-byte unsigned int in the request field (see argpingdata struct below), \texttt{null} (0) in response, and its time offset, which is the different between the current time and its base time. It notes the time it sends this packet. \tbd{this one in particular relies on seeing the structure. Should I just go ahead and throw them all in here?}
	\item Local notes the time it sent the request
	\item Remote validates the message and responds with a new \texttt{PING}, giving a new random request integer (if a follow up request is desired), the received response int set to the request int, and its own time offset.
	\item Local ensures received response int matches the request int it sent.
	\item Local determines the connection latency from the send time, then remote's time base is calculated based on half of this. That is, $\text{remote time base} = \text{received time offset} - \frac{\text{latency}}{2}$. This value is saved and used in \ac{IP} calculations for the remote gateway in the future.
	\item Local marks the remote gateway as having time sync data available and, if connection data is available, remote is marked as connected. 
\end{enumerate}

\subsection{Trust Data Exchange}
\begin{enumerate}
	\item For each gateway it knows about, local sends a \texttt{TRUST\_DATA} packet to remote, containing the gateway name, base \ac{IP}, \ac{IP} mask, and public key.
	\item Remote validates the message, then adds the data in each \texttt{TRUST\_DATA} packet to their list of gateways (if they don't already have it). At this point the new gateway appears just like one read in from a configuration file.
	\item After some period of time, remote attempts to connect to the new gateway, just as they would any other gateway they had not yet successfully contacted.
 \end{enumerate}

\subsection{Route packet}
\label{sec:arg_protocol_route}
\begin{enumerate}
	\item Local takes outbound packet and encrypts with with remote symmetric key.
	\item Local sends WRAPPED message to remote current IP with the encrypted packet included. An \ac{HMAC} of the packet is included in the header.
	\item Remote receives and validates the message.
	\item Remote sends the original, decrypted packet into the internal network.
\end{enumerate}

